## 这是关于 module 相关的使用介绍
mpstore 可以创建模块，来对 state 进行模块化分割。模块是独立的也是关联在一起的，这是什么意思？整个 state 是一个巨大的 object。假如有以下数据结构。

```js
{
  a: {
    c: {

    },
  },
  b: {
    d: {

    },
  },
  f: {

  },
}
```
对于这个结构，如果我们要做模块化区分，我们可以这样认为
1. 整个 global state 我们可以看作一个唯一的全局的模块
2. state.a 可以看成一个模块
3. state.a.c 也可以看作为一个模块
4. state.b 可以看成一个模块
5. state.b.d 也可以看作为一个模块
6. state.f 不看作为一个模块，看作为一个普通的 object

这样做，会让每一个个 object 成为一个模块，每个 object 是独立，但是模块与普通的 object 是有区分的，所以不能简单的让每一个 object 看作一个模块，因为没有办法进行区分。假如更改为以下语法

```js
{
  a: createModule({
    c: createModule({

    }),
  }),
  b: createModule({
    d: createModule({

    }),
  }),
  f: {

  },
}
```

这样就可以区分哪些 object 是模块，哪些不是了。但是还有几个问题需要考虑，这是以上述语法建立模块体系必须要考虑到的问题
1. 模块之间是可以嵌套的？
2. 模块可以处于非模块的 object 中吗？
3. 模块可以随意删除和增改吗？
4. 如果可以随意删除增改，子模块将如果处理？
5. 模块如何合并？
6. 如果父模块中命名空间被占用，子模块需要使用相同的命名空间将如何处理？

以下回答是对上述问题的约定，也就是通过这种模块体系时，必须要遵守的约定，否则，将会导致整个模块体系的崩溃
+ 可以简单的理解为模块将将比普通字段的优先级更改，将有更严格的检测和限制

#### 模块之间是可以嵌套的？
模块之间必须是可以嵌套的，这是建立当前模块体系的基础，也就是说，下面 demo 是成立的
```js
{
  a: createModule({
    b: createModule({

    }),
  }),
}
```

#### 模块可以处于非模块的 object 中吗？
不允许，因为这将导致每一个普通对象的合并都需要大量的检测，带来的性能消耗太大，而且对非模块的 object 限制太大，下面的 demo 是不成立的
```js
// 在 mpstore 中，这种语法是不被允许的，但不是会报错
// 但这会导致 b 模块是个无效的模块，你将无法使用他，并且无法通过 mpstore 的一些列辅助语法得到他
// 所以千万不要这样写
{
  a: {
    b: createModule({}),
  },
}
```